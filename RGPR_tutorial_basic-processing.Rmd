---
title: "RGPR tutorial - Basic GPR data processing"
author: "Emanuel Huber (emanuel.huber@stanford.edu)"
date: "11 April 2016"
output: 
  html_document: 
    fig_caption: yes
    keep_md: yes
    number_sections: yes
    self_contained: no
    theme: journal
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/home/huber/WORK/UNIBAS/RESEARCH/RGPR/tutorial/2014_04_25_frenke") 
```

`RGPR` is a package for [R](https://cran.r-project.org/) to read, write, analyse and visualise ground-penetrating radar (GPR) data.

> R is a [free] programming language and software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing ([Wikipedia > R](https://en.wikipedia.org/wiki/R_%28programming_language%29)).

**Note**: This R-package is still in development, and therefore some of the functions may change in a near future. The R-package `RGPR` is hosted on [GitHub](https://github.com/) at [https://github.com/emanuelhuber/RGPR](https://github.com/emanuelhuber/RGPR). You can contribute to the development of `RGPR`: create an account on [GitHub](https://github.com/), [fork](https://guides.github.com/activities/forking/) `RGPR`, improve it and sumbmit your modifications.

If you have any questions, comments or wishes, etc. feel free to contact me (in english, french or german)

> `emanuel.huber@stanford.edu`

# Objectives of this tutorial
* Learn some basics of ground-penetrating radar data processing with `RGPR`.
* Learn how to manipulate objects of the class `RGPR`.

However, this tutorial will not explain you the math/algorithms behind the different processing methods.

In this tutorial the code snippets are in monospaced typewriter font like in the following example:
```{r, eval=FALSE, echo=TRUE}
1 + exp(1:10)
```

The R output are preceded by a double hash (`##`). The following R output is from the code snippet above.
```{r, eval=TRUE,echo=FALSE}
1 + exp(1:10)
```

Create a text file and save it with the `.R` extension (the extension for the R-script files). Then copy the code snippets into your R-script file and adapt them to your needs. To run the code in R, copy the code and paste it into the R console. You can also manually enter the code.

Don't hesitate to consult the help files and to search for help on the internet. For example, to see the help for the function `mean()`, enter:

```{r,eval=FALSE}
?mean    # open the help file related to the function mean()
```

# Preliminary

* Read the tutorial [RGPR - Getting started (tutorial 1)](http://emanuelhuber.github.io/RGPR/RGPR_tutorial_installation-load.html)
* Download the data [2014_04_25_frenke.zip](http://emanuelhuber.github.io/RGPR/2014_04_25_frenke.zip)

## File organisation
I recommand you to first think about the organisation of your files and directories. I suggest to organise them as follows:
```
/2014_04_25_frenke   (project directory with date and location)
    /processing      (here you will save the processed GPR files)
    /rawGPR          (the raw GPR data, never modify them!)
    RGPR_tutorial.R  (this is you R script for this tutorial)
```


## Install/load the necessary packages
Load the packages `RGPR` and `rChoiceDialogs` (`rChoiceDialogs` provides a collection of portable choice dialog widgets):
```{r, warning=FALSE, message=FALSE}
library(RGPR)   # load RGPR in the current R session
library(rChoiceDialogs)
```

[optionally] If `RGPR` is not installed, follow the instructions of the tutorial "Getting started" to install it.

[optionally] If R answers you `there is no package called 'rChoiceDialogs'` you need first to install `rChoiceDialogs`, either through your R software or directly in R with:
```{r, eval=FALSE}
install.packages("rChoiceDialogs")
```

The warnings that R shows can be ignored.

## Set the working directory
The working directory must be correctly set to use relative filepath. The working directory can be set either in your R-software or in R directly with:
```{r}
myDir <- "/home/huber/WORK/UNIBAS/RESEARCH/RGPR/tutorial/2014_04_25_frenke"
setwd(myDir)    # set the working directory
getwd()         # Return the current working directory (just to check)
```

[optionally] Alternatively, you can use an interactive dialog box from the R-package `rChoiceDialogs`:
```{r, eval=FALSE}
myDir <- rchoose.dir(default = "/home/huber/WORK/UNIBAS/RESEARCH/RGPR/")
setwd(myDir)    # set the working directory
getwd()         # Return the current working directory (just to check)
```

# Read GPR data
The raw GPR data are located in the directory `/rawGPR`. The data format is the Sensor & Softwares format. Each GPR data consists of 

* a header file (extension `.hd`) that can be opened with a normal text editor,
* and a binary data file (extension `.DT1`).

To read the Sensor & Softwares GPR data, enter

```{r, echo=TRUE}
A <- readGPR(fPath = "rawGPR/LINE00.DT1")   # the filepath is case sensitive!
```

If the filepath (argument `fPath`) is not correct compared with the working directory, an error message is thrown.

More information on the structure of an object of the class `RGPR` (like `A`) can be found in the tutorial "RGPR tutorial - `RGPR` class"

# Plot the GPR data
To plot the GPR record as a raster image (default mode), enter
```{r, echo=TRUE}
plot(A)                                 
```


Plot wiggles
```{r, echo=TRUE}
plot(A, type = "wiggles")          
```

A few remarks:

* the horizontal red line indicates first wave arrival time,
* the yellow triangle indicates the position of a fiducial marker that was set 
during the survey to mark something (a specific object close to the GPR line, a 
change in morphology/topography/sedimentology, an intersection with another GPR 
line, etc.). These markers are very useful to add topographic data to the GPR 
profile, particularly when the fiducial markers correspond to the locations 
where the (x,y,z) coordinates were measured.


Plot a section/subset of the GPR record (like zooming)
```{r, echo=TRUE}
# plot the 100 to 300 samples of the traces 15 to 150
plot(A[100:300, 15:150])        
```

Plot a signal trace, notice that the signal is clipped to \(+/-50\,mV\) 
(between \(0\) and \(20\,ns\):
```{r, echo=TRUE}
plot(A[, 15])      # plot the 15th trace of the GPR-line   
```

Note: the `@3.5m` in the plot title indicate the relative position of the trace
on the GPR profile.

Plot the first 40 trace samples:
```{r, echo=TRUE}
# plot the first 40 samples of the 15th trace of the GPR profile
plot(A[1:40, 15])  
```

# Basic processing steps

## DC shift removal
Plot a single trace:
```{r, echo=TRUE}
plot(A[, 15])  # plot the 15th trace of the GPR-line
```

Notice how the trace samples before the first wave arrival (before 
\(t = 0\,ns\)) are slightly shifted below \(0\,mV\)? This shift is called 
direct current offset (DC-offset) and you will remove it from the data. The 
direct current offset is estimated on trace samples before time-zero. 

1. Determine which samples will be used to estimate the direct current offset 
(i.e., the samples before the first wave arrival). Identify the samples before 
\(t = 0\,ns\) by ploting the first n samples of the traces. For example, for 
\(n = 110\):

```{r, echo=TRUE}
 # plot the first 110 samples of the 15th trace of the GPR profile
plot(A[1:110, 15]) 
```

2. Remove the DC-offset estimated on the first n samples usind the function 
`dcshift()`. This function takes as argument the `GPR` object and the sample 
index used to estimate the DC shift (in this case, the first \(110\) samples):
```{r, echo=TRUE}
A1 <- dcshift(A, 1:110)   # new object A1 
```


You can visualise the DC-offset on the trace plot by adding an horizontal
lines (`abline(h=...)`) with the argument  `h` equal the DC-offset, i.e., the
mean of the first \(110\) samples (`mean(A[1:110,15]`):
```{r, echo=TRUE}
plot(A[, 15])  # plot the 15th trace of the GPR-line 
# add a green horizontal line
abline(h = mean(A[1:110, 15]), col = "green") 
```


Have a look at A1:
```{r, echo=TRUE}
A1
```

Compared with `A` or `print(A)`, two additional lines are displayed. The second 
line shows the applied processing step, `dcshift`, with the arguments passed to 
the function. 
Each time a GPR object is processed with a function, the name of the function 
as well as some of its arguments are stored in the GPR object. This enables to 
track the data processing, i.e., to know exactly which processing steps where 
applied to the data. This is a first step toward reproducible research.

The processing steps can be extracted with the function `processing()`:
```{r, echo=TRUE}
processing(A1)
```


## Dewow
Remove the low-frequency components (the so-called "wow") of the GPR record 
usind 

1. either a median absolute deviation (MAD) filter (`type = "MAD"`).
2. or a Gaussian filter (`type = "Gaussian"`). The Gaussian filter is faster 
than the MAD filter. 

In both cases, the argument `w` is the length of the filter in time units.
```{r, echo=TRUE,message=FALSE}
A2 <- dewow(A1, type = "MAD", w = 50)     # dewowing
plot(A2)                                  # plot the result
```

Can you see the difference with `A1`? Plot `A2 - A1` to see the removed "wow".
```{r, echo=TRUE,message=FALSE}
plot(A2 - A1)                           # plot the difference
```


See the dewowing by comparing the traces before (blue line) and after 
(red line):
```{r, echo=TRUE,message=FALSE}
plot(A1[,15], col = "blue")      # before dewowing
lines(A2[,15], col = "red")      # after dewowing
```


## Time gain
Apply a gain to compensate the signal attenuation. Three types of gain are 
disponible:

* power gain (`type = power`): \(A_g(t) = A(t)\cdot t^\alpha \) with 
\(\alpha = 1 \) per default.
* exponential gain (`type = exp`): \(A_g(t) = A(t)\cdot \exp(\alpha \cdot t)\).
* Automatic gain control (`type = agc`): make gain equal to the local root mean 
squared signal.

We will first apply a power gain and then an exponential gain.
To visualise the amplitude of the GPR signal as a function of time, use the 
function `plotAmpl()` as follows:
```{r, echo=TRUE}
plotAmpl(A2, col = "black")          # plot amplitude as a function of time

```

On the previous plot, there is a sharp amplitude increase at about \(50\,ns\) 
corresponding to the first wave arrival. Then the amplitude decreases until a 
plateau at about \(200\,ns\). This plateau corresponds to the signal noise. 
There is little hope to extract some useful information above \(200\,ns\) 
because above \(200\,ns\) the signal/noise ratio is much smaller than \(1\) 
(i.e., more noise than signal).

### Power gain
The power gain is set constant until `t_cst = 100` ns and applied from 
\(100\,ns\) to `t_end = 200` ns, with \(\alpha = 1\).
```{r, echo=TRUE}
A3 <- gain(A2, type = "power", alpha = 1, t_end = 200, t_cst = 100)
```

Compare the amplitude before and after the power gain:
```{r, echo=TRUE}
plotAmpl(A3, col = "red")
# set add=TRUE to add the amplitude on the previous plot
plotAmpl(A2, col = "black", add = TRUE)   
plot(A3)        # how does it look after the gain?
```

Plot the difference (after - before gaining)
```{r, echo=TRUE}
plot(A3 - A2)
```


### Exponential gain

Ideally, the parameter \(\alpha\) in the exponential gain should be close to 
the slope of the amplitude decrease. This slope could be estimated by fitting 
a straight line to the amplitude decrease. We only want to apply the filter 
between \(50\,ns\) (`t_0`) and \(200\,ns\) (`t_end`):
```{r, echo=TRUE}
A4 <- gain(A3, type ="exp",  alpha = 0.2, t_0 = 50, t_end = 200)
plotAmpl(A4, col = "green")
```

Oops! Set `alpha` to a smaller value!
```{r, echo=TRUE}
A4 <- gain(A3, type = "exp", alpha = 0.09, t_0 = 50, t_end = 180)
plotAmpl(A4, col = "green")
plotAmpl(A3, col = "red", add = TRUE) 
plotAmpl(A2, col = "black", add = TRUE) 
plot(A4)    # how does it look after the gain?
```

Plot the gained GPR record and clip the amplitude values to \(50\,mV\) using 
the argument `clip`:
```{r, echo=TRUE}
plot(A4, clip = 50)    # how does it look after the gain?
```

Plot the difference (after - before gaining)
```{r, echo=TRUE}
plot(A4 - A3, clip = 50)
```

## Frequency filter

Let's have a look at the amplitude-frequency and phase-frequency plot 
(the spectrum given by the Fourier decomposition):
```{r, echo=TRUE}
spec(A4)
```

The curve in red is the averaged amplitude/phase over all the trace 
amplitudes/phases.

On the first plot, notice 

* a sharp decrease of the amplitude between \(0\,MHz\) and \(10\,MHz\): these 
frequency correspond to the slowing-varying part of the signal.
* after a peak at \(80\,MHz\) (the returned signal frequency that is lower than 
the antenna frequency because of frequency-dependent attenuation in the ground), 
the amplitude decreases.
* at about \(200\,MHz\) the amplitude stays constant (plateau): noise frequency.

Eliminate the low-frequency as well as the high-frequency (noise) component of 
the GPR record with a bandpass filter. We define as corner frequencies 
\(5\,MHz\), \(15\,MHz\), \(150\,MHz\) and \(260\,MHz\), and set 
`plotSpec = TRUE` to plot the spectrum with the signal, the filtered signal and 
the filter.
```{r, echo=TRUE}
A5 <- fFilter(A4, f = c(5, 15, 150, 260), type = "bandpass", plotSpec = TRUE)
plot(A5, clip = 50)
```

Let see the difference
```{r, echo=TRUE}
plot(A5 - A4, clip = 50)
```

Ideally, the objective of processing is to remove the noise component without 
deterioring the signal component to improve the signal/noise ratio. When 
ploting the difference in processing (after - before), one should only observe 
the noise that is filtered out. However, in practice some part of the signal 
may be also deteriored when eliminating noise.

## Median filter (spatial filter)
```{r, echo=TRUE}
A6 <- filter2D(A5,type="median3x3")
plot(A6 , clip = 50)
```

Let see the difference
```{r, echo=TRUE}
plot(A6 - A5, clip = 50)
```

## Frequency-wavenumber filter (f-k-filter)

The function `spec()` with the argument `type = "f-k` returns a list containing 
the frequencies (f), the wavenumbers (k), the amplitude of the GPR data.

```{r, echo=TRUE}
FKSpec <- spec(A6, type = "f-k")
area <- list(x = c(0, min(FKSpec$wnb), min(FKSpec$wnb), max(FKSpec$wnb), max(FKSpec$wnb), 0),
             y = c(max(FKSpec$fre), 800, 0, 0, 800, max(FKSpec$fre) ))
lines(area, type="o")
A7 <- fkFilter(A6, fk = area)
```

With the f-k-filter you can successfully remove the artifacts but still 
the information gained is very small in this case (the quality of the
raw GPR data is already bad):
```{r, echo=TRUE}
plot(A7, clip = 50)
spec(A7, type = "f-k")
```

<!---
By ploting the spectrum of the filtered GPR data you see that some 
```{r, echo=TRUE}
spec(A7, type = "f-k")
```
-->

## Processing overview
Let review the processing step applied on the GPR record:
```{r, echo=TRUE}
processing(A6)
```


## Save and export

Save the processed GPR record into the directory /processing. Use the `.rds` 
format (this is a R internal format)
```{r, echo=TRUE}
writeGPR(A7, fPath = file.path(getwd(), "processing",paste0(name(A7),".rds")), 
         format = "rds", overwrite = TRUE)
```
 
Export a high quality PDF: 
```{r, results='hide'} 
exportPDF(A7, clip = 30, fPath = file.path(getwd(), 
          paste0("processing/", name(A7))),
          lwd = 0.5, ws = 1.5)
```

## Read the saved GPR data
```{r, echo=TRUE} 
procA <- readGPR(fPath = file.path(getwd(), "processing/LINE00.rds")) 
```          

Plot to check if everything is ok:
```{r, echo=TRUE} 
plot(procA, clip = 50)
``` 


# Complete processing code
Now, your R-script file should look like:
```{r, eval=FALSE}
library(RGPR)   # load RGPR in the current R session
library(rChoiceDialogs)

myDir <- "/home/huber/WORK/UNIBAS/RESEARCH/RGPR/tutorial/2014_04_25_frenke"
setwd(myDir)    # set the working directory
getwd()         # Return the current working directory (just to check)

# read the raw GPR dat
A <- readGPR(fPath = "rawGPR/LINE00.DT1") 

# DC-offset shift
A1 <- dcshift(A, 1:110)   # new object A1 

# dewow
A2 <- dewow(A1, type = "MAD", w = 50)     # dewowing

# power gain
A3 <- gain(A2, type = "power", alpha = 1, t_end = 200, t_cst = 100)

# exponential gain
A4 <- gain(A3, type = "exp", alpha = 0.09, t_0 = 50, t_end = 180)

# frequency filter (bandpass)
A5 <- fFilter(A4, f = c(5, 15, 150, 260), type = "bandpass", plotSpec = FALSE)

# Spatial filter (median)
A6 <- filter2D(A5, type = "median3x3")

# frequency-wavenumber filter (f-k-filter)
FKSpec <- spec(A6, type = "f-k")
area <- list(x = c(0, min(FKSpec$wnb), min(FKSpec$wnb), max(FKSpec$wnb), max(FKSpec$wnb), 0),
             y = c(max(FKSpec$fre), 800, 0, 0, 800, max(FKSpec$fre) ))
lines(area, type="o")
A7 <- fkFilter(A6, fk = area)

# save the GPR object
writeGPR(A7, fPath = file.path(getwd(), "processing",paste0(name(A7),".rds")), 
         format = "rds", overwrite = TRUE)

# export PDF
exportPDF(A7, clip = 30, fPath = file.path(getwd(), 
          paste0("processing/", name(A7))),
          lwd = 0.5, ws = 1.5)        

# read the processed GPR data
procA <- readGPR(fPath = file.path(getwd(), "processing/LINE00.rds")) 

plot(procA, type = "wiggles")

```


# Some final thoughts
Warning: processing can 
introduce artifacts in the data and lead to false interpreations.

> What really matters is that the final interpretation is valid, 
and although processing is important, ultimately, the key to good data
interpretation is good data collection in the first place.   
*in Cassidy (2009) Chapter 5 - Ground Penetrating Radar Data Processing, 
Modelling and Analysis, In Ground Penetrating Radar Theory and Applications, 
(Eds Harry M. Jol,), Elsevier, Amsterdam, pp: 141-176, ISBN 9780444533487*.

> A good practical mantra for most users to adopt is if it cannot be
seen in the raw data – is it really there? As such, processing steps 
should be used to improve the raw-data quality, therefore, making 
interpretation easier. In practice, this means increasing the 
signal-to-noise ratio of coherent responses and presenting the data 
in a format that reflects the subsurface conditions accurately.   
*in Cassidy (2009) Chapter 5 - Ground Penetrating Radar Data Processing, 
Modelling and Analysis, In Ground Penetrating Radar Theory and Applications, 
(Eds Harry M. Jol,), Elsevier, Amsterdam, pp: 141-176, ISBN 9780444533487*.

> Processing of GPR data tends to improve the appearance of data, but rarely
does processing substantially change the interpretation.    
*in Daniels et al. (1997) Coincident Antenna Three-Dimensional GPR.
Journal of Environmental and Engineering Geophysics, Vol. 2, No.1, pp. 1–9*.



***

Notes

* This document was created with R-markdown and knitr.
